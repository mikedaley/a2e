#include "preferences.hpp"
#include <fstream>
#include <iostream>
#include <sstream>
#include <cstdlib>

preferences::preferences(const std::string& app_name)
{
  // Get home directory
  const char* home = std::getenv("HOME");
  if (!home)
  {
    home = ".";
  }

  // Create config directory path: ~/.config/app_name/
  std::filesystem::path config_dir = std::filesystem::path(home) / ".config" / app_name;

  // Create directory if it doesn't exist
  try
  {
    std::filesystem::create_directories(config_dir);
  }
  catch (const std::exception& e)
  {
    std::cerr << "Failed to create config directory: " << e.what() << std::endl;
  }

  // Set config file path
  config_path_ = config_dir / "preferences.ini";
}

bool preferences::load()
{
  std::ifstream file(config_path_);
  if (!file.is_open())
  {
    // File doesn't exist yet, not an error
    return true;
  }

  data_.clear();

  std::string line;
  while (std::getline(file, line))
  {
    // Skip empty lines and comments
    if (line.empty() || line[0] == '#' || line[0] == ';')
    {
      continue;
    }

    // Parse key=value
    size_t equals_pos = line.find('=');
    if (equals_pos != std::string::npos)
    {
      std::string key = line.substr(0, equals_pos);
      std::string value = line.substr(equals_pos + 1);

      // Trim whitespace
      key.erase(0, key.find_first_not_of(" \t"));
      key.erase(key.find_last_not_of(" \t") + 1);
      value.erase(0, value.find_first_not_of(" \t"));
      value.erase(value.find_last_not_of(" \t") + 1);

      data_[key] = value;
    }
  }

  return true;
}

bool preferences::save()
{
  std::ofstream file(config_path_);
  if (!file.is_open())
  {
    std::cerr << "Failed to open preferences file for writing: " << config_path_ << std::endl;
    return false;
  }

  // Write header
  file << "# Application Preferences\n";
  file << "# This file is automatically generated\n\n";

  // Write all key-value pairs
  for (const auto& [key, value] : data_)
  {
    file << key << "=" << value << "\n";
  }

  return true;
}

bool preferences::getBool(const std::string& key, bool default_value) const
{
  auto it = data_.find(key);
  if (it == data_.end())
  {
    return default_value;
  }

  const std::string& value = it->second;
  return value == "true" || value == "1" || value == "yes" || value == "on";
}

void preferences::setBool(const std::string& key, bool value)
{
  data_[key] = value ? "true" : "false";
}

int preferences::getInt(const std::string& key, int default_value) const
{
  auto it = data_.find(key);
  if (it == data_.end())
  {
    return default_value;
  }

  try
  {
    return std::stoi(it->second);
  }
  catch (const std::exception&)
  {
    return default_value;
  }
}

void preferences::setInt(const std::string& key, int value)
{
  data_[key] = std::to_string(value);
}

std::string preferences::getString(const std::string& key, const std::string& default_value) const
{
  auto it = data_.find(key);
  if (it == data_.end())
  {
    return default_value;
  }
  return it->second;
}

void preferences::setString(const std::string& key, const std::string& value)
{
  data_[key] = value;
}

bool preferences::hasKey(const std::string& key) const
{
  return data_.find(key) != data_.end();
}

